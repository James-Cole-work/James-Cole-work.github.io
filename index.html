<!DOCTYPE html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" 
          content="width=device-width, 
                   initial-scale=1.0">
    <title>Exomars Target Selector</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div id="threejs-container">
        <div id="threejs-canvas"></div>
        <div id="sidebar">
          
          <button name = 'login' > Login</button>
          <button name = 'logout' > Logout</button><br /><br /><br />
 
          <div class="dropdown">
          
            <select id="solSelect">
            <option value="NoSol">Select Sol</option>

            <option value="Sol1">Sol1</option>
            <option value="Sol2">Sol2</option>
            <option value="Sol3">Sol3</option>
            </select>
          </div><br /><br /><br />

          <button onclick="zoomIn()">Zoom In</button><br />
          <button onclick="zoomOut()">Zoom Out</button><br />
          <button onclick="resetView()">Reset View</button><br /><br /><br />

          <button name = 'targetclear' onclick="clearMarkers()"> Clear Current Targets</button><br />
          <button name = 'targetsend'> Send and Confirm Targets</button><br /><br /><br />


          <a><button onclick = "jsonDownload()"> Download Suggestions </button></a><br />
          <label for="myfile">Upload Suggestions</label> <br />
          <form action="">
          <input type="file" id="jsonFile" accept=".json">
          <input type="button"  value="Submit" onclick = "jsonUpload()">
        </form> <br /><br /><br />


          <div>
            <input type="checkbox" onclick = "coordGrid()" id="scales" name="scales"/>
            <label for="scales">Coordinate Gridlines</label>
          </div>
            <div>
            <input type="checkbox" onclick = "markerShow()" id="markerShow" name="markerShow" checked/>
            <label for="markerShow">Show Suggestions</label>
          </div>
          
          
          




        </div>
      </div>


      <div id="popupForm" style="display:none;" class="popup">
        <form id="markerForm">
          <label>Title: <input type="text" name="title" /></label><br />
          <label>Description: <textarea name="description"></textarea></label><br />
          <label><input type="checkbox" name="enfys" /> Enfys Target?</label><br />
          <label><input type="checkbox" name="HRC" /> HRC Target?</label><br />
          <button type="submit">Save</button>
          <button type="button" onclick="closePopup()">Cancel</button>
        </form>
      </div>

      <div id="tooltip" style="display:none; position:absolute; background:white; border:1px solid black; padding:5px; pointer-events:none; z-index:100;"></div>
      
<!-- Three.js core -->
<script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
<!-- OrbitControls -->
<script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>
    const container = document.getElementById('threejs-canvas');
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.transparent=true;
    renderer.alpha=true;
    container.appendChild(renderer.domElement);

    let sphere; // Make it accessible globally

    let gen_radius = 5; //general radius for spheres

    //'ZCAM-0360-ZCAM08390-L-RAD-ALL-79-MOSAIC-SPHR-20250430Texture.tif.json'
    let sphereCoords;
    let mapTransform;
    let mapWidth;
    let mapHeight;



async function solSelect1() {
    const response = await fetch('ZCAM-0360-ZCAM08390-L-RAD-ALL-79-MOSAIC-SPHR-20250430Texture.tif.json');
    if (!response.ok) throw new Error('Failed to fetch');
    const data = await response.json();

    return {
        sphereCoords: data.geometry_information.sphere_center,
        mapTransform: data.map_transformation,
        mapWidth: data.image_width,
        mapHeight: data.image_height
    };
}
            
solSelect1().then(({ sphereCoords, mapTransform, mapWidth, mapHeight }) => {
    // You can now use sphereCoords and mapTransform here
    console.log(sphereCoords, mapTransform, mapWidth, mapHeight);
  
});


async function loadJsonData(jsonPath) {
  try {
    const response = await fetch(jsonPath);
    if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
    const data = await response.json();
    return {
        sphereCoords: data.geometry_information.sphere_center,
        mapTransform: data.map_transformation,
        mapWidth: data.image_width,
        mapHeight: data.image_height
    };
  } catch (error) {
    console.error(`Failed to load ${jsonPath}:`, error);
    return null;
  }
}


  const loader = new THREE.TextureLoader();

  loader.load(
'mars1.png', // Path to texture
(texture) => {
  console.log('Texture loaded successfully');

  const radius = 15;
  const widthSegments = 32
  const heightSegments = 8
  const phiStart = 0
  const phiLength = Math.PI*2
  const thetaStart = 0
  const thetaLength = Math.PI

  const geometry = new THREE.SphereGeometry(gen_radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength)
  const material = new THREE.MeshBasicMaterial({
    color: 0x0000ff,       // Blue color
    wireframe: true,       // Show only wireframe
  });

  sphere = new THREE.Mesh(geometry, material);
  sphere.name = "mySphere";
  scene.add(sphere);


  animate(); // Start animation once texture is loaded
},
undefined, // Optional callback for progress (can be omitted)
(error) => {
  console.error('Error loading texture:', error);
}
);
    
let currentTexturePath = 'SelectSol';
let lastTexturePath = null;
let TextureLoad = null;
let CoordsLoad = null;
let transConst = (100/90)*(Math.PI/180)
const textureLoader = new THREE.TextureLoader();



function watchTextureChange() {
  if (currentTexturePath !== lastTexturePath) {
    // Texture changed
    lastTexturePath = currentTexturePath;

    if (currentTexturePath == 'Sol1') {
      TextureLoad = 'mars1.png';
      CoordsLoad = 'mars1.json';
      resetView();
    }
    if (currentTexturePath == 'Sol2') {
      TextureLoad = 'ZCAM-0360-ZCAM08390-L-RAD-ALL-79-MOSAIC-SPHR-20250430Texture_uint8.jpg';
      CoordsLoad = 'ZCAM-0360-ZCAM08390-L-RAD-ALL-79-MOSAIC-SPHR-20250430Texture.tif.json';
      resetView();
    }

    if (currentTexturePath == 'Sol3') {
      TextureLoad = 'mars1.png';
      CoordsLoad = 'mars2.json';
      resetView();
    }

    if (TextureLoad !== null) {
    // Load and update sphere texture
    textureLoader.load(TextureLoad, (newTexture) => {
      clearMarkers();
      
       
      // Example 2: Load mars data later
      setTimeout(() => {
        loadJsonData(CoordsLoad).then(data => {
          if (data) {
              const radius = 15;
              const widthSegments = 32
              const heightSegments = 32
              const phiStart = data.mapTransform[0]*transConst
              const phiLength = data.mapTransform[1]*data.mapWidth*transConst
              const thetaStart = Math.PI-data.mapTransform[3]*transConst
              const thetaLength = data.mapTransform[5]*data.mapHeight*transConst
              sphere.geometry = new THREE.SphereGeometry(gen_radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength)
              sphere.material = new THREE.MeshBasicMaterial({ map: newTexture, side: THREE.BackSide});
              sphere.position.set(0,0,0);


              newTexture.wrapS = THREE.RepeatWrapping;
              newTexture.repeat.x = - 1;

            }
        });
      }, 2.5); // Load after 5 seconds


    });
  }



  }

  // Keep checking
  requestAnimationFrame(watchTextureChange);
}

// Start watching
watchTextureChange();

document.getElementById('solSelect').addEventListener('change', (e) => {
  currentTexturePath = e.target.value; // triggers update on next check
});


    
    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      2000
    );
    camera.position.set(-1, 0, 0
    );
    camera.lookAt( new THREE.Vector3(0,0,1));

    const axesHelper = new THREE.AxesHelper(100);
    scene.add(axesHelper);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableZoom = false;
    controls.zoomSpeed = 3;
    controls.enablePan = true;
    controls.enableRotate = true;
    controls.minDistance = 0.1;
    controls.maxDistance = 800;
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.mouseButtons.MIDDLE = null;



  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();

  const markers = [];

  let xdata = 0;
  let ydata= 0;
  let zdata= 0;


  let lastClickPosition = null;


    window.addEventListener('dblclick', (event) => {
    if (!sphere) {
        console.warn('Sphere not yet loaded');
        return;
    }

    // Adjust for canvas offset
    const rect = renderer.domElement.getBoundingClientRect();
    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);
    sphere.updateMatrixWorld(); // Ensure transforms are up-to-date

    const intersects = raycaster.intersectObject(sphere);
    console.log('Raycast intersects:', intersects);

    if (intersects.length > 0 && intersects[0].object.name === "mySphere") {
        lastClickPosition = intersects[0].point.clone();
        showPopup(mouse.x, mouse.y);
    }
});
const suggestionData = [];
document.getElementById("markerForm").addEventListener("submit", (e) => {
  e.preventDefault();

  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

  const formData = new FormData(e.target);
  const data = Object.fromEntries(formData.entries());


  data.enfys = formData.has("enfys");
  data.hrc = formData.has("HRC");

  const spherical = new THREE.Spherical();
  spherical.setFromVector3(lastClickPosition);

  var pan = -spherical.theta * (180/Math.PI) + 90; // Azimuthal angle in degrees
  const tilt = - spherical.phi * (180/Math.PI) + 90 ;     // Polar angle in degrees

  if (pan > 180) {
    pan  = pan - 360;
  }


  const PTU = [pan, tilt];

  data.position  = PTU;
  data.mouse = lastClickPosition;

  if (lastClickPosition) {
    placeMarker(lastClickPosition, data);

  }
  suggestionData.push(data);


  closePopup();
  e.target.reset();
});


let hrc_present = false;
let enfys_present = false;

// Tooltip on hover
renderer.domElement.addEventListener("mousemove", (event) => {
  const rect = renderer.domElement.getBoundingClientRect();
    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;


  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(markers);

  const tooltip = document.getElementById("tooltip");



  if (intersects.length > 0) {
    const marker = intersects[0].object;
    const data = marker.userData;


    tooltip.style.left = `${event.clientX + 10}px`;
    tooltip.style.top = `${event.clientY + 10}px`;
    tooltip.style.display = "block";
    tooltip.width = '150px';
    let xround = Number(marker.position.x);
    let yround = Number(marker.position.y);
    let zround = Number(marker.position.z);
    const spherical = new THREE.Spherical();
    spherical.setFromVector3(marker.position);

    // Now you can access:
    const r = spherical.radius;
    var theta = -spherical.theta * (180/Math.PI) + 90; // Azimuthal angle in degrees
    const phi = - spherical.phi * (180/Math.PI) + 90 ;     // Polar angle in degrees

    if (theta > 180) {
      theta  = theta - 360;
    }

    const rround = r;
    const thetaround = theta;
    const phiround = phi;

    tooltip.innerHTML = `
      <strong>${data.title || "Untitled"}</strong><br>
      <em>${data.description || "No description"}</em><br>
      <em>x: ${xround.toFixed(2)},</em>
      <em>y: ${yround.toFixed(2)},</em>
      <em>z: ${zround.toFixed(2)}</em><br>
      <em>Pan Angle: ${thetaround.toFixed(2)},</em>
      <em>Tilt Angle: ${phiround.toFixed(2)}</em><br>
      <label>
        <input type="checkbox" disabled ${data.enfys ? "checked" : ""} /> Enfys Target?
      </label><br>
      <label>
        <input type="checkbox" disabled ${data.hrc ? "checked" : ""} /> HRC Target?
      </label><br>
    `;
      if (data.hrc === true) {
      if (!hrc_present) {
        
        const markerPhi = phi;
        const markerTheta = theta;
        ;
        const hrcangle = 2.5*(Math.PI/180);

        const hrc = new THREE.Mesh(
          new THREE.SphereGeometry(gen_radius-0.2, 16, 16, markerTheta+Math.PI/2-hrcangle, hrcangle*2, markerPhi-hrcangle, hrcangle*2 ),
          new THREE.MeshBasicMaterial({ color: 0x0000ff, transparent: true, opacity: 0.2, side: THREE.BackSide })
        );

        hrc.name = "hrc";
        hrc.position.set(0, 0, 0);// Use the object's center
        scene.add(hrc);
        hrc_present = true;
      }
    }
    if (data.enfys === true) {
      if (!enfys_present) {
        
        const markerPhi = phi;
        const markerTheta = theta;
        const enfysangle = 0.5*(Math.PI/180);

        const enfys = new THREE.Mesh(
          new THREE.SphereGeometry(gen_radius-0.2, 16, 16, markerTheta+Math.PI/2-enfysangle, enfysangle*2, markerPhi-enfysangle, enfysangle*2 ),
          new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.2, side: THREE.BackSide })
        );


        enfys.name = "enfys";
        enfys.position.set(0, 0, 0);// Use the object's center
        scene.add(enfys);
        enfys_present = true;
      }
    }
   
  } else {
    tooltip.style.display = "none";

    // Remove existing HRC if present
    const hrc = scene.getObjectByName('hrc');
    if (hrc) {
      scene.remove(hrc);
      hrc.geometry.dispose();
      hrc.material.dispose();
      hrc_present = false;
    }
    const enfys = scene.getObjectByName('enfys');
    if (enfys) {
    scene.remove(enfys);
    enfys.geometry.dispose();
    enfys.material.dispose();
    enfys_present = false;
    }
  }
});



function showPopup(x, y) {  //gives form to fill out by user about target
  const popup = document.getElementById("popupForm");
  popup.style.left = `${x}px`;
  popup.style.top = `${y}px`;
  popup.style.display = "block";


}

function closePopup() { //closes form when done
  const popup = document.getElementById("popupForm");
  popup.style.display = "none";
}
let markerit  = 0;

function placeMarker(position, data) {

  textureLoader.load('Flag.png', (markerTexture) => {

  const marker = new THREE.Mesh(
    new THREE.PlaneGeometry(0.4, 0.4),
    new THREE.MeshBasicMaterial({ map: markerTexture, side: THREE.DoubleSide,   transparent: true})
  );


  markerit += 1;
  marker.position.copy(position);

  const offset = 0.1;

  const direction = position.clone().normalize(); 
  marker.position.add(direction.multiplyScalar(-offset));
  const center = new THREE.Vector3(0, 0, 0); 
  marker.lookAt(center);

  marker.userData = data;
  marker.userData.id = markerit;

  scene.add(marker);
  markers.push(marker);

  });


}

function clearMarkers() {
  // 1. Remove each marker from scene and dispose resources
  markers.forEach(marker => {
    scene.remove(marker);

    // dispose geometry
    if (marker.geometry) {
      marker.geometry.dispose();
    }
    // dispose material
    if (marker.material) {
      marker.material.dispose();
    }
  });

  // 2. Clear the markers array
  markers.length = 0;

  // 3. (Optional) Reset the ID counter
  markerit = 0;

  markers.clear;
}

var w = innerWidth / 1.5, h = innerHeight / 1.5;
const rect = renderer.domElement.getBoundingClientRect();
const label = document.createElement('div');
label.style.position = 'absolute';
label.style.top = '10px';
label.style.left = '10px';
label.style.color = 'white';
label.style.fontFamily = 'monospace';
document.body.appendChild(label);
function updateCameraLookAtPoint() {
          const direction = new THREE.Vector3();
          camera.getWorldDirection(direction);

          const lookDistance = 1000; // Arbitrary distance to project the direction
          const lookAtPoint = camera.position.clone().add(direction.multiplyScalar(lookDistance));

          label.textContent = `Looking at: x=${lookAtPoint.x.toFixed(2)}, y=${lookAtPoint.y.toFixed(2)}, z=${lookAtPoint.z.toFixed(2)}`;

        }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      updateCameraLookAtPoint(); // Show look direction
      renderer.render(scene, camera);
    }



    window.addEventListener('wheel', (event) => {
  if (event.deltaY < 0) {

    camera.zoom *= 1.5;
    camera.updateProjectionMatrix();
  } else if (event.deltaY > 0) {

    camera.zoom /= 1.5;
    camera.updateProjectionMatrix();
  }
});


    function zoomIn() {
      camera.zoom *= 1.5;
      camera.updateProjectionMatrix();
    }

    function zoomOut() {
      camera.zoom /= 1.5;
      camera.updateProjectionMatrix();
    }

    function resetView() {
      camera.zoom = 1;
      camera.position.set(-1, 0, 0
        );
      camera.lookAt( new THREE.Vector3(0,0,1));
      camera.updateProjectionMatrix();
    }

    function solSelect() {
      document.getElementById("myDropdown").classList.toggle("show");
    }
    let grid_status = true;
    function coordGrid() {
        if (grid_status === true) {

            const radius = gen_radius-0.1;
            const segments = 360/15;
            const rings = 180/15;
            const material = new THREE.LineBasicMaterial({ color: 0xff0000 });
            const gridGeometry = new THREE.BufferGeometry();
                  
            const positions = [];
            // Latitude lines
            for (let i = 1; i < rings; i++) {
              const theta = (i * Math.PI) / rings;
              const ring = [];
              for (let j = 0; j <= segments; j++) {
                const phi = (j * 2 * Math.PI) / segments;
                const x = radius * Math.sin(theta) * Math.cos(phi);
                const y = radius * Math.cos(theta);
                const z = radius * Math.sin(theta) * Math.sin(phi);
                ring.push(x, y, z);
              }
              for (let k = 0; k < ring.length - 3; k += 3) {
                positions.push(
                  ring[k], ring[k + 1], ring[k + 2],
                  ring[k + 3], ring[k + 4], ring[k + 5]
                );
              }
            }
            // Longitude lines
            for (let i = 0; i < segments; i++) {
              const phi = (i * 2 * Math.PI) / segments;
              const line = [];
              for (let j = 0; j <= rings; j++) {
                const theta = (j * Math.PI) / rings;
                const x = radius * Math.sin(theta) * Math.cos(phi);
                const y = radius * Math.cos(theta);
                const z = radius * Math.sin(theta) * Math.sin(phi);
                line.push(x, y, z);
              }
              for (let k = 0; k < line.length - 3; k += 3) {
                positions.push(
                  line[k], line[k + 1], line[k + 2],
                  line[k + 3], line[k + 4], line[k + 5]
                );
              }
            }
              const labelGroup = new THREE.Group();
              labelGroup.name = 'gridlabels';
              scene.add(labelGroup);
                  // Function to create text sprite
             function makeLabel(text, position) {
                  

                  const canvas = document.createElement('canvas');
                  canvas.width = 400;
                  canvas.height = 128;
                  const ctx = canvas.getContext('2d');
                  ctx.fillStyle = 'white';
                  ctx.font = '128px sans-serif';
                  ctx.fillText(text, 60, 128);

                  const texture = new THREE.CanvasTexture(canvas);
                  const material = new THREE.SpriteMaterial({ map: texture, transparent: true, depthTest: false, });
                  const sprite = new THREE.Sprite(material);
                  sprite.scale.set(0.5, 0.25, 1);
                  sprite.renderOrder = 999; 
                  sprite.name = 'gridlabels';
                  sprite.position.copy(position.clone().multiplyScalar(1.1));
                  scene.add(sprite);

                  const labelGroup = scene.getObjectByName('gridlabels');
                  if (labelGroup) labelGroup.add(sprite);
                }

                // Add labels for latitude (horizontal)
                [ -90, -60, -30, 0, 30, 60, 90 ].forEach(lat => {
                  const theta = THREE.MathUtils.degToRad(90 - lat);
                  const phi = 0; // Prime meridian
                  const x = (radius) * Math.sin(theta) * Math.cos(phi);
                  const y = (radius) * Math.cos(theta);
                  const z = (radius) * Math.sin(theta) * Math.sin(phi);
                  makeLabel(`${lat}°`, new THREE.Vector3(x, y, z));
                });

                // Add labels for longitude (vertical arcs)
                [ 0, 45, 90, 135, 180, -45, -90, -135 ].forEach(lon => {
                  const theta = Math.PI / 2; // Equator
                  const phi = THREE.MathUtils.degToRad(lon);
                  const x = (radius) * Math.sin(theta) * Math.cos(phi);
                  const y = (radius) * Math.cos(theta);
                  const z = (radius) * Math.sin(theta) * Math.sin(phi);
                  makeLabel(`${lon}°`, new THREE.Vector3(x, y, z));
                });

            gridGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const grid = new THREE.LineSegments(gridGeometry, material);
            scene.add(grid);


            grid.position.set(0, 0, 0);
            grid.name = 'gridlines';
            scene.add(grid);
            grid_status = false;




        } else {
            const grid = scene.getObjectByName('gridlines');
            if (grid) scene.remove(grid);
            const gridlabels = scene.getObjectByName('gridlabels');
            if (gridlabels) scene.remove(gridlabels);
            grid_status = true;
        }
    }
    let marker_status = true;

    function markerShow() {

        if (marker_status === true) {
        markers.forEach(marker => {
          scene.remove(marker);

        });
        marker_status = false;
        } else {
          markers.forEach(marker => {
          scene.add(marker);
        });
        marker_status = true;

      }
    }

    // Close the dropdown menu if the user clicks outside of it
    window.onclick = function(event) {
      if (!event.target.matches('.dropbtn')) {
        var dropdowns = document.getElementsByClassName("dropdown-content");
        var i;
        for (i = 0; i < dropdowns.length; i++) {
          var openDropdown = dropdowns[i];
          if (openDropdown.classList.contains('show')) {
            openDropdown.classList.remove('show');
          }
        }
      }
    }

let hrcPreview = null;
let controlPressed = false;

function onMouseMove(event) {
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

  raycaster.setFromCamera(mouse, camera);

  const intersects = raycaster.intersectObject(sphere);

  if (intersects.length > 0) {
    const intersectPoint = intersects[0].point.clone();

    // Convert intersection point to spherical coordinates
    const spherical = new THREE.Spherical();
    spherical.setFromVector3(intersectPoint);

    if (hrcPreview) {
      scene.remove(hrcPreview);
      hrcPreview.geometry.dispose();
      hrcPreview.material.dispose();
      hrcPreview = null;
    }

    const hrcangle = 2.5 * (Math.PI / 180);

    hrcPreview = new THREE.Mesh(
      new THREE.SphereGeometry(
        gen_radius - 0.2,
        16,
        16,
        spherical.theta + Math.PI / 2 - hrcangle,
        hrcangle * 2,
        spherical.phi - hrcangle,
        hrcangle * 2
      ),
      new THREE.MeshBasicMaterial({
        color: 0x0000ff,
        transparent: true,
        opacity: 0.4,
        side: THREE.BackSide,
        depthTest: false,
      })
    );

    hrcPreview.position.set(0, 0, 0);
    scene.add(hrcPreview);
  }
}

function onKeyDown(event) {
  if (event.key === "Control" && !controlPressed) {
    controlPressed = true;
    renderer.domElement.addEventListener("mousemove", onMouseMove);
  }
}

function onKeyUp(event) {
  if (event.key === "Control") {
    controlPressed = false;
    renderer.domElement.removeEventListener("mousemove", onMouseMove);

    if (hrcPreview) {
      scene.remove(hrcPreview);
      hrcPreview.geometry.dispose();
      hrcPreview.material.dispose();
      hrcPreview = null;
    }
  }
}

window.addEventListener("keydown", onKeyDown);
window.addEventListener("keyup", onKeyUp);

function jsonDownload(){
    const a = document.querySelector('a');

    //suggestionData.push(markers);

    const data = JSON.stringify(suggestionData, null, 2);

    const blob = new Blob([data], {type: 'text/json'});

    const url = URL.createObjectURL(blob);

    a.href = url;
    a.download = 'example.json';
}

let uploadedJson = null;
document.getElementById('jsonFile').addEventListener('change', function(event) {
            const file = event.target.files[0];
            clearMarkers();
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    uploadedJson = JSON.parse(e.target.result);
                    console.log("JSON loaded successfully:", uploadedJson);

                    // Now you can use uploadedJson anywhere in your code
                } catch (error) {
                    console.error('Invalid JSON file.', error);
                }
            };
            reader.readAsText(file);
        });

function jsonUpload() {

  if (uploadedJson) {
                console.log("Using JSON data:", uploadedJson);

                for (let i = 0; i < uploadedJson.length; i++) {
                
                const mouse = uploadedJson[i].mouse;

                const position = new THREE.Vector3(mouse.x, mouse.y, mouse.z);

                const data = uploadedJson[i];
                placeMarker(position, data);
                }

            } else {
                console.warn("No JSON file uploaded yet.");
            }
        }



  </script>

</body>
</html>