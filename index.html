<!DOCTYPE html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" 
          content="width=device-width, 
                   initial-scale=1.0">
    <title>PASTI - PAncam Suggested Target Interface</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
  <div id = "container">
    <div id="threejs-container">
        <div id="threejs-canvas"></div>
        
      </div>

<div id="sidebar">
          <div class="container">
          <button name = 'login' style = 'width: 8vw'> Login</button>
          <button name = 'logout'style = 'width: 8vw' > Logout</button>
            </div>
          <div class="dropdown" id="solSelector">
          
            <select title = "SolSelect"id="solSelect"  style = 'height: 4vh'>
            <option value="NoSol">Select Sol</option>

            <option value="Sol1">Sol1</option>
            <option value="Sol2">Sol2</option>
            <option value="Sol3">Sol3</option>
            <option value="Sol4">Sol4</option>
            </select>
          </div><br />
          <div class="container">
          <button onclick="zoomIn()"style = 'width: 8vw'>Zoom In</button>
          <button onclick="zoomOut()"style = 'width: 8vw'>Zoom Out</button>
          </div>
          <button onclick="resetView()">Reset View</button><br />

          <button name = 'targetclear' onclick="clearMarkers()"> Clear Current Targets</button>
          <button name = 'targetsend'> Send and Confirm Targets</button><br />


          <a><button onclick = "jsonDownload()" id ="download"> Download Suggestions </button></a><br />
          <label for="download"  style = 'font-size: 2vh;'>Upload Suggestions</label>
          <input type="file" id="jsonFile" accept=".json" style = 'font-size: 2vh;' title="jsondown">
          <input type="button"  value="Submit" onclick = "jsonUpload()" style = 'font-size: 2vh;'>
        </form> 
          <br />
          <div>
            <input type="checkbox" onclick = "coordGrid()" id="scales" name="scales" />
            <label for="scales" style = 'font-size: 2vh;'>Coordinate Gridlines</label>
          </div>
            <div>
            <input type="checkbox" onclick = "markerShow()" id="markerShow" name="markerShow" checked/>
            <label for="markerShow" style = 'font-size: 2vh;'>Show Suggestions</label>
          </div>
        <br/><br/><br/><br/><br/><br/>
        <p>Right Click: Pan <br/>W: WAC FoV <br/>H: HRC FoV <br/>E: Enfys FoV</p>
        </div>

        </div>

      <div id="popupForm" style="display:none; font-size: 2vh; width: 35vw; height: 80vh;" class="popup">
        <form id="markerForm">
          <label>Suggestion Title: <input type="text" name="title" /></label><br />
          <label>Suggestion ID: <input type="text" name="suggestionID" disabled /></label><br />
          <label>User ID: <input type="text" name="userID" disabled /></label><br />
          <label>Suggestion Description:<br/><textarea name="description"></textarea></label><br />
          <label>Science Intent:<br/><textarea name="intent" ></textarea></label><br />

          <label>HRC:<input type="checkbox" name="HRC" /></label>
          <label>Enfys:<input type="checkbox" name="enfys" /></label><br />
          <label>WAC RGB:<input type="checkbox" name="wacRGB" /></label>
          <label>WAC Multispectral:<input type="checkbox" name="wacmulti" /></label><br />
          <label>Mosaic:<input type="checkbox" name="mosaic" /></label><br />

          <label>Keywords:<div class="dropdown" id="keywords">
            <select title = "Select Keywords"id="keywords"  style = 'height: 4vh'>
            <option value="nokw">Select Keywords</option>

            <option value="kw1">Keyword 1</option>
            <option value="kw2">Keyword 2</option>
            <option value="kw3">Keyword 3</option>
            </select>
          </div></label><br />
          <label><input type="text" name="selectedkeyywords" disabled /></label><br />

          <label>Other Notes:<br/><textarea name="notes"></textarea></label><br />

          <button type="submit">Save</button>
          <button type="button" onclick="closePopup()">Cancel</button>
        </form>
      </div>
      
      <div id="tooltip" style="display:none; position:absolute; background:white; border:1px solid black; padding:5px; pointer-events:none; z-index:100;"></div>
      
<!-- Three.js core -->
<script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
<!-- OrbitControls -->
<script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>
    const container = document.getElementById('threejs-canvas');
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.transparent=true;
    renderer.alpha=true;
    container.appendChild(renderer.domElement);

    
    console.log("Canvas size:", renderer.domElement.width, renderer.domElement.height);

    let sphere; // Make it accessible globally

    let gen_radius = 1000; //general radius for spheres

    //'ZCAM-0360-ZCAM08390-L-RAD-ALL-79-MOSAIC-SPHR-20250430Texture.tif.json'
    let sphereCoords;
    let mapTransform;
    let mapWidth;
    let mapHeight;

 const viewSize = gen_radius/5; // controls how much of the inside is visible
    const scene = new THREE.Scene();
    const aspect = window.innerWidth / window.innerHeight;
const camera = new THREE.PerspectiveCamera(
    60, window.innerWidth / window.innerHeight, 0.1, 1500
);

    camera.position.set(-0.1, 0, 0);


    const axesHelper = new THREE.AxesHelper(100);
    axesHelper.material.transparent = true;
    axesHelper.material.opacity = 0.5;
    //scene.add(axesHelper);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    //controls.enableZoom = true;
    controls.minDistance = 0.1;
    controls.maxDistance = gen_radius * 0.5;
    controls.zoomSpeed = 1;
    controls.minZoom = 0.1;
    controls.enablePan = true;
    controls.enableDamping = true;
    controls.dampingFactor = 0.2;
    controls.rotateSpeed = -0.1; 

    controls.mouseButtons = {
  LEFT: null,
  MIDDLE:null,
  RIGHT: THREE.MOUSE.ROTATE   
};
function zoomCamera(delta) {

    camera.fov = THREE.MathUtils.clamp(camera.fov + delta, 20, 60);
    camera.updateProjectionMatrix();

}

// Example: attach to mouse wheel
window.addEventListener('wheel', (e) => {
    e.preventDefault();
    zoomCamera(e.deltaY * 0.05);
}, { passive: false });


async function solSelect1() {
    const response = await fetch('ZCAM-0360-ZCAM08390-L-RAD-ALL-79-MOSAIC-SPHR-20250430Texture.tif.json');
    if (!response.ok) throw new Error('Failed to fetch');
    const data = await response.json();

    return {
        sphereCoords: data.geometry_information.sphere_center,
        mapTransform: data.map_transformation,
        mapWidth: data.image_width,
        mapHeight: data.image_height
    };
}
            
solSelect1().then(({ sphereCoords, mapTransform, mapWidth, mapHeight }) => {
    // You can now use sphereCoords and mapTransform here
    console.log(sphereCoords, mapTransform, mapWidth, mapHeight);
  
});
const label = document.createElement('div');
label.style.position = 'absolute';
label.style.top = '95vh';
label.style.left = '10px';
label.style.padding = '5px';
label.style.background = 'rgba(0,0,0,0.5)';
label.style.color = 'white';
label.style.fontFamily = 'monospace';
label.style.zIndex = '100';
document.body.appendChild(label);

const markers = [];
let markerit  = 0;

async function loadJsonData(jsonPath) {
  try {
    const response = await fetch(jsonPath);
    if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
    const data = await response.json();
    return {
                sphereCoords: data.geometry_information.sphere_center,
                mapTransform: data.map_transformation,
                mapWidth: data.image_width,
                mapHeight: data.image_height



    };
  } catch (error) {
    console.error(`Failed to load ${jsonPath}:`, error);
    return null;
  }
}


  const loader = new THREE.TextureLoader();

  loader.load(
'mars1.png', // Path to texture
(texture) => {
  console.log('Texture loaded successfully');

  const radius = gen_radius;
  const widthSegments = 32
  const heightSegments = 64
  const phiStart = 0
  const phiLength = Math.PI*2
  const thetaStart = 0
  const thetaLength = Math.PI

  const geometry = new THREE.SphereGeometry(gen_radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength)
  const material = new THREE.MeshBasicMaterial({
    color: 0x00ffff,       // Blue color
    wireframe: true,       // Show only wireframe
  });

  sphere = new THREE.Mesh(geometry, material);
  sphere.name = "mySphere";
  scene.add(sphere);


  animate(); // Start animation once texture is loaded
},
undefined, // Optional callback for progress (can be omitted)
(error) => {
  console.error('Error loading texture:', error);
}
);
    
let currentTexturePath = 'SelectSol';
let lastTexturePath = null;
let TextureLoad = null;
let CoordsLoad = null;
let transConst = (100/90)*(Math.PI/180)
const textureLoader = new THREE.TextureLoader();


const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

function watchTextureChange() {
  if (currentTexturePath !== lastTexturePath) {
    // Texture changed
    lastTexturePath = currentTexturePath;

    if (currentTexturePath == 'Sol1') {
      TextureLoad = 'mars1.png';
      CoordsLoad = 'mars1.json';
      resetView();
    }
    if (currentTexturePath == 'Sol2') {
      TextureLoad = 'ZCAM-0360-ZCAM08390-L-RAD-ALL-79-MOSAIC-SPHR-20250430Texture_uint8.jpg';
      CoordsLoad = 'ZCAM-0360-ZCAM08390-L-RAD-ALL-79-MOSAIC-SPHR-20250430Texture.tif.json';
      resetView();
    }

    if (currentTexturePath == 'Sol3') {
      TextureLoad = 'mars1.png';
      CoordsLoad = 'mars2.json';
      resetView();
    }

    
    if (currentTexturePath == 'Sol4') {
      TextureLoad = '2025-10-13_JR_ExoMars_GTM_Products\\PanCam\\2022-10-04_Mini-SVT-1\\S0006Q001_mosaic_left\\Mosaic\\browse\\pan_der_sc_l_mosaic_20221004t103007.137z_20221004t103123.416z.png';
      CoordsLoad = '2025-10-13_JR_ExoMars_GTM_Products\\PanCam\\2022-10-04_Mini-SVT-1\\S0006Q001_mosaic_left\\Mosaic\\browse\\pan_der_sc_l_mosaic_20221004t103007.137z_20221004t103123.416z_ValidateReport.json';
      resetView();
    }


    if (TextureLoad !== null) {
    // Load and update sphere texture
    textureLoader.load(TextureLoad, (newTexture) => {
      clearMarkers();
    
      setTimeout(() => {
        loadJsonData(CoordsLoad).then(data => {
          if (data) {
              const widthSegments = 32
              const heightSegments = 64
              const phiStart = data.mapTransform[0]*transConst
              const phiLength = data.mapTransform[1]*data.mapWidth*transConst
              const thetaStart = Math.PI-data.mapTransform[3]*transConst
              const thetaLength = data.mapTransform[5]*data.mapHeight*transConst
              sphere.geometry = new THREE.SphereGeometry(gen_radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength)
              sphere.material = new THREE.MeshBasicMaterial({ map: newTexture, side: THREE.BackSide});
              sphere.position.set(0,0,0);


              newTexture.wrapS = THREE.RepeatWrapping;
              newTexture.repeat.x = - 1;

            }
        });
      }, 2.5); // Load after 5 seconds


    });
  }



  }

  // Keep checking
  requestAnimationFrame(watchTextureChange);
}

// Start watching
watchTextureChange();

document.getElementById('solSelect').addEventListener('change', (e) => {
  currentTexturePath = e.target.value; // triggers update on next check
});


const radius = 10;
const curve = new THREE.CatmullRomCurve3([]);

for (let lat = -90; lat <= 90; lat += 1) {
  const theta = THREE.MathUtils.degToRad(90 - lat);
  const phi = THREE.MathUtils.degToRad(180);
  const x = radius * Math.sin(theta) * Math.cos(phi);
  const y = radius * Math.cos(theta);
  const z = radius * Math.sin(theta) * Math.sin(phi);
  curve.points.push(new THREE.Vector3(x, y, z));
}

// Tube geometry along the curve
const tubeGeometry = new THREE.TubeGeometry(curve, 64, 0.02, 8, false);
const tubeMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
const thickLine = new THREE.Mesh(tubeGeometry, tubeMaterial);
scene.add(thickLine);


const panBar = document.createElement('div');
panBar.style.position = 'absolute';
panBar.style.top = '0px';
panBar.style.left = '2vh';
panBar.style.width = '70vw';
panBar.style.height = '2vh';
panBar.style.backgroundColor = '#fff';
panBar.style.zIndex = '101';
document.body.appendChild(panBar);

const panMarker = document.createElement('div');
panMarker.style.position = 'absolute';
panMarker.style.top = '0px';
panMarker.style.width = '2px';
panMarker.style.height = '100%';
panMarker.style.backgroundColor = 'red';
panBar.appendChild(panMarker);

// Vertical Tilt bar (left)
const tiltBar = document.createElement('div');
tiltBar.style.position = 'absolute';
tiltBar.style.top = '2vh';
tiltBar.style.left = '0px';
tiltBar.style.width = '2vh';
tiltBar.style.height = '90vh';
tiltBar.style.backgroundColor = '#fff';
tiltBar.style.zIndex = '101';
document.body.appendChild(tiltBar);

const tiltMarker = document.createElement('div');
tiltMarker.style.position = 'absolute';
tiltMarker.style.left = '0px';
tiltMarker.style.width = '100%';
tiltMarker.style.height = '2px';
tiltMarker.style.backgroundColor = 'blue';
tiltBar.appendChild(tiltMarker);






function updateCameraRulers() {
    // Get the camera direction
    const direction = new THREE.Vector3();
    camera.getWorldDirection(direction); // normalized vector

    // Convert to spherical coordinates
    const spherical = new THREE.Spherical();
    spherical.setFromVector3(direction);

    let pan = -spherical.theta * (180/Math.PI) + 90;   // Azimuth
    let tilt = -spherical.phi * (180/Math.PI) + 90;    // Polar
    if(pan > 180) pan -= 360;

    // Move Pan marker (horizontal)
    const panNorm = (pan + 180) / 360; // map -180..180 to 0..1
    const panWidth = panBar.clientWidth;
    panMarker.style.left = `${panNorm * panWidth}px`;

    // Move Tilt marker (vertical)
    const tiltNorm = (90 - tilt) / 180; // map +90..-90 to 0..1
    const tiltHeight = tiltBar.clientHeight;
    tiltMarker.style.top = `${tiltNorm * tiltHeight}px`;

    // Optional: update label
    //label.textContent = `Camera: Pan = ${pan.toFixed(2)}, Tilt = ${tilt.toFixed(2)}`;
}

const zeroPad = (num, places) => String(num).padStart(places, '0')

  let xdata = 0;
  let ydata= 0;
  let zdata= 0;

  const userid = 'Cole_User';
  let suggestionid = 0;

  let s_input = document.querySelector('input[name="suggestionID"]');
  let u_input = document.querySelector('input[name="userID"]');
  let lastClickPosition = null;


    window.addEventListener('dblclick', (event) => {
    if (!sphere) {
        console.warn('Sphere not yet loaded');
        return;
    }
    suggestionid = suggestionid +1;
    // Adjust for canvas offset
    const rect = renderer.domElement.getBoundingClientRect();
    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);
    sphere.updateMatrixWorld(); // Ensure transforms are up-to-date


    s_input.value = zeroPad(suggestionid,4);
    u_input.value = userid;

    const intersects = raycaster.intersectObject(sphere);
    console.log('Raycast intersects:', intersects);

    if (intersects.length > 0 && intersects[0].object.name === "mySphere") {
        lastClickPosition = intersects[0].point.clone();
        showPopup(mouse.x, mouse.y);
    }
});
const suggestionData = [];

document.getElementById("markerForm").addEventListener("submit", (e) => {
  e.preventDefault();

  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

  const formData = new FormData(e.target);
  const data = Object.fromEntries(formData.entries());

  data.userid = userid;
  data.suggestionid = zeroPad(suggestionid, 4);

  data.enfys = formData.has("enfys");
  data.hrc = formData.has("HRC");
  data.wacrgb = formData.has("wacRGB");
  data.wacmulti = formData.has("wacmulti");
  data.mosaic = formData.has("mosaic");

  const spherical = new THREE.Spherical();
  spherical.setFromVector3(lastClickPosition);

  var pan = -spherical.theta * (180/Math.PI) + 90; // Azimuthal angle in degrees
  const tilt = - spherical.phi * (180/Math.PI) + 90 ;     // Polar angle in degrees

  if (pan > 180) {
    pan  = pan - 360;
  }


  const PTU = [pan, tilt];

  data.position  = PTU;
  data.mouse = lastClickPosition;

  //Insert other data here.


  

  if (lastClickPosition) {
    placeMarker(lastClickPosition, data);

  }
  suggestionData.push(data);


  closePopup();
  e.target.reset();
});


let hrc_present = false;
let enfys_present = false;

// Tooltip on hover
renderer.domElement.addEventListener("mousemove", (event) => {
  const rect = renderer.domElement.getBoundingClientRect();
    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;


  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(markers);

  const tooltip = document.getElementById("tooltip");



  if (intersects.length > 0) {
    const marker = intersects[0].object;
    const data = marker.userData;


    tooltip.style.left = `${event.clientX + 10}px`;
    tooltip.style.top = `${event.clientY + 10}px`;
    tooltip.style.display = "block";
    tooltip.width = 'width: 35vw';
    let xround = Number(marker.position.x);
    let yround = Number(marker.position.y);
    let zround = Number(marker.position.z);
    const spherical = new THREE.Spherical();
    spherical.setFromVector3(marker.position);

    // Now you can access:
    const r = spherical.radius;
    var theta = -spherical.theta * (180/Math.PI) + 90; // Azimuthal angle in degrees
    const phi = - spherical.phi * (180/Math.PI) + 90 ;     // Polar angle in degrees

    if (theta > 180) {
      theta  = theta - 360;
    }

    const rround = r;
    const thetaround = theta;
    const phiround = phi;

    tooltip.innerHTML = `
      <strong>Suggestion Title: ${data.title|| "Untitled"}</strong><br>
      <em>User ID: ${data.userid || "No description"}</em><br>
      <em>Suggestion ID: ${data.suggestionid || "No description"}</em><br>
      <em>Suggestion Description: ${data.description || "No description"}</em><br>
      <em>Science Intent: ${data.intent || "No description"}</em><br>
      <em>Pan Angle: ${thetaround.toFixed(2)},</em>
      <em>Tilt Angle: ${phiround.toFixed(2)}</em><br>
      <label>HRC: <input type="checkbox" disabled ${data.hrc ? "checked" : ""} />
      </label>
      <label>Enfys: <input type="checkbox" disabled ${data.enfys ? "checked" : ""} />
      </label><br>
      <label>WAC RGB: <input type="checkbox" disabled ${data.wacrgb ? "checked" : ""} />
      </label>
      <label>WAC Multi: <input type="checkbox" disabled ${data.wacmulti ? "checked" : ""} />
      </label><br>
      <label>Mosaic: <input type="checkbox" disabled ${data.mosaic ? "checked" : ""} />
      </label><br>
      <em>Keywords: ${data.keywords || "No description"}</em><br>
      <em>Other Notes: ${data.notes || "No description"}</em><br>

    `;
      if (data.hrc === true) {
      if (!hrc_present) {
        
        const markerPhi = phi;
        const markerTheta = theta;
        ;
        const hrcangle = 0.5*4.88*(Math.PI/180);

        const hrc = new THREE.Mesh(
          new THREE.SphereGeometry(gen_radius-0.2, 16, 16, markerTheta+Math.PI/2-hrcangle, hrcangle*2, markerPhi-hrcangle, hrcangle*2 ),
          new THREE.MeshBasicMaterial({ color: 0x0000ff, transparent: true, opacity: 0.2, side: THREE.BackSide })
        );

        hrc.name = "hrc";
        hrc.position.set(0, 0, 0);// Use the object's center
        scene.add(hrc);
        hrc_present = true;
      }
    }
    if (data.enfys === true) {
      if (!enfys_present) {
        
        const markerPhi = phi;
        const markerTheta = theta;
        const enfysangle = 0.5*(Math.PI/180);

        const enfys = new THREE.Mesh(
          new THREE.SphereGeometry(gen_radius-0.2, 16, 16, markerTheta+Math.PI/2-enfysangle, enfysangle*2, markerPhi-enfysangle, enfysangle*2 ),
          new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.2, side: THREE.BackSide })
        );


        enfys.name = "enfys";
        enfys.position.set(0, 0, 0);// Use the object's center
        scene.add(enfys);
        enfys_present = true;
      }
    }
   
  } else {
    tooltip.style.display = "none";

    // Remove existing HRC if present
    const hrc = scene.getObjectByName('hrc');
    if (hrc) {
      scene.remove(hrc);
      hrc.geometry.dispose();
      hrc.material.dispose();
      hrc_present = false;
    }
    const enfys = scene.getObjectByName('enfys');
    if (enfys) {
    scene.remove(enfys);
    enfys.geometry.dispose();
    enfys.material.dispose();
    enfys_present = false;
    }
  }
});

function showPopup(x, y) {  //gives form to fill out by user about target
  const popup = document.getElementById("popupForm");
  popup.style.left = `${x}px`;
  popup.style.top = `${y}px`;
  popup.style.display = "block";


}

function closePopup() { //closes form when done
  const popup = document.getElementById("popupForm");
  popup.style.display = "none";
}

function placeMarker(position, data) {

  textureLoader.load('Flag.png', (markerTexture) => {

  const marker = new THREE.Mesh(
    new THREE.PlaneGeometry(50, 50),
    new THREE.MeshBasicMaterial({ map: markerTexture, side: THREE.DoubleSide,   transparent: true})
  );


  markerit += 1;
  marker.position.copy(position);

  const offset = gen_radius/10;

  const direction = position.clone().normalize(); 
  marker.position.add(direction.multiplyScalar(-offset));
  const center = new THREE.Vector3(0, 0, 0); 
  marker.lookAt(center);

  marker.userData = data;
  marker.userData.id = markerit;

  scene.add(marker);
  markers.push(marker);

  });


}

function clearMarkers() {
  // 1. Remove each marker from scene and dispose resources
  markers.forEach(marker => {
    scene.remove(marker);

    // dispose geometry
    if (marker.geometry) {
      marker.geometry.dispose();
    }
    // dispose material
    if (marker.material) {
      marker.material.dispose();
    }
  });

  // 2. Clear the markers array
  markers.length = 0;

  // 3. (Optional) Reset the ID counter
  markerit = 0;

  markers.clear;
}

var w = innerWidth / 1.5, h = innerHeight / 1.5;
const rect = renderer.domElement.getBoundingClientRect();


renderer.domElement.addEventListener('mousemove', (event) => {
    const rect = renderer.domElement.getBoundingClientRect();

    // Convert mouse position to normalized device coordinates (-1 to +1)
    const mouse = new THREE.Vector2();
    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

    // Raycast from camera through mouse
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);

    const intersects = raycaster.intersectObject(sphere);
    
    if (intersects.length > 0) {
        const point = intersects[0].point;
        const spherical = new THREE.Spherical().setFromVector3(point);

        let pan = -spherical.theta * (180 / Math.PI) + 90;   // Azimuth
        let tilt = -spherical.phi * (180 / Math.PI) + 90;    // Polar
        if (pan > 180) pan -= 360;
        label.textContent = `Pan: ${pan.toFixed(2)}, Tilt: ${tilt.toFixed(2)}`;
    } else {
        label.textContent = `Pan: --, Tilt: --`;
    }
});


    function animate() {
      requestAnimationFrame(animate);
      //updateCameraLookAtPoint(); // Show look direction
      controls.update();
      updateCameraRulers();
      renderer.render(scene, camera);
    }





    function zoomIn() {
      camera.zoom *= 1.5;
      camera.updateProjectionMatrix();
    }

    function zoomOut() {
      camera.zoom /= 1.5;
      camera.updateProjectionMatrix();
    }

    function resetView() {
      camera.zoom = 1;
      camera.position.set(-0.1, 0, 0
        );


      camera.updateProjectionMatrix();
    }

    function solSelect() {
      document.getElementById("myDropdown").classList.toggle("show");
    }
    let grid_status = true;
    function coordGrid() {
        if (grid_status === true) {

            const radius = gen_radius*0.99;
            const segments = 360/45;
            const rings = 180/30;
            const material = new THREE.LineBasicMaterial({ color: 0x00ffff });
            const gridGeometry = new THREE.BufferGeometry();
                  
            const positions = [];
            // Latitude lines
            for (let i = 1; i < rings; i++) {
              const theta = (i * Math.PI) / rings;
              const ring = [];
              for (let j = 0; j <= segments; j++) {
                const phi = (j * 2 * Math.PI) / segments;
                const x = radius * Math.sin(theta) * Math.cos(phi);
                const y = radius * Math.cos(theta);
                const z = radius * Math.sin(theta) * Math.sin(phi);
                ring.push(x, y, z);
              }
              for (let k = 0; k < ring.length - 3; k += 3) {
                positions.push(
                  ring[k], ring[k + 1], ring[k + 2],
                  ring[k + 3], ring[k + 4], ring[k + 5]
                );
              }
            }
            // Longitude lines
            for (let i = 0; i < segments; i++) {
              const phi = (i * 2 * Math.PI) / segments;
              const line = [];
              for (let j = 0; j <= rings; j++) {
                const theta = (j * Math.PI) / rings;
                const x = radius * Math.sin(theta) * Math.cos(phi);
                const y = radius * Math.cos(theta);
                const z = radius * Math.sin(theta) * Math.sin(phi);
                line.push(x, y, z);
              }
              for (let k = 0; k < line.length - 3; k += 3) {
                positions.push(
                  line[k], line[k + 1], line[k + 2],
                  line[k + 3], line[k + 4], line[k + 5]
                );
              }
            }
              const labelGroup = new THREE.Group();
              labelGroup.name = 'gridlabels';
              scene.add(labelGroup);
                  // Function to create text sprite
             function makeLabel(text, position) {
                  console.log('help');
                  const canvas = document.createElement('canvas');
                  canvas.width = 1024; // 2x width
                  canvas.height = 512; // 2x height
                  const ctx = canvas.getContext('2d');
                  ctx.fillStyle = 'white';
                  ctx.font = '80px Arial';
                  ctx.textAlign = 'center';
                  ctx.textBaseline = 'middle';
                  ctx.fillText(text, canvas.width / 2, canvas.height / 2);

              

                  const texture = new THREE.CanvasTexture(canvas);
                  texture.needsUpdate = true;
                  const material = new THREE.SpriteMaterial({ map: texture, transparent: true, depthTest: false, depthWrite: false});
                  const sprite = new THREE.Sprite(material);

                  const labelSize = gen_radius * 0.5; // adjust this multiplier
                  sprite.scale.set(labelSize, labelSize / 2, 1);

                  // Position the label slightly off the surface of the sphere
                  sprite.position.copy(position.clone().multiplyScalar(1.05));
                  sprite.name = 'gridlabels';
                  sprite.position.copy(position.clone().multiplyScalar(1.1));

                  const labelGroup = scene.getObjectByName('gridlabels');
                  if (labelGroup) labelGroup.add(sprite);
                }

                // Add labels for latitude (horizontal)
                [ -90, -60, -30, 0, 30, 60, 90 ].forEach(lat => {
                  const theta = THREE.MathUtils.degToRad(90 - lat);
                  const phi = 0; // Prime meridian
                  const x = (radius) * Math.sin(theta) * Math.cos(phi);
                  const y = (radius) * Math.cos(theta);
                  const z = (radius) * Math.sin(theta) * Math.sin(phi);
                  makeLabel(`${lat}°`, new THREE.Vector3(x, y, z));
                });

                // Add labels for longitude (vertical arcs)
                [ 0, 45, 90, 135, 180, -45, -90, -135 ].forEach(lon => {
                  const theta = Math.PI / 2; // Equator
                  const phi = THREE.MathUtils.degToRad(lon);
                  const x = (radius) * Math.sin(theta) * Math.cos(phi);
                  const y = (radius) * Math.cos(theta);
                  const z = (radius) * Math.sin(theta) * Math.sin(phi);
                  makeLabel(`${lon}°`, new THREE.Vector3(x, y, z));
                });

            gridGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const grid = new THREE.LineSegments(gridGeometry, material);
            scene.add(grid);


            grid.position.set(0, 0, 0);
            grid.name = 'gridlines';
            scene.add(grid);
            grid_status = false;




        } else {
            const grid = scene.getObjectByName('gridlines');
            if (grid) scene.remove(grid);
            const gridlabels = scene.getObjectByName('gridlabels');
            if (gridlabels) scene.remove(gridlabels);
            grid_status = true;
        }
    }
    let marker_status = true;

    function markerShow() {

        if (marker_status === true) {
        markers.forEach(marker => {
          scene.remove(marker);

        });
        marker_status = false;
        } else {
          markers.forEach(marker => {
          scene.add(marker);
        });
        marker_status = true;

      }
    }

    // Close the dropdown menu if the user clicks outside of it
    window.onclick = function(event) {
      if (!event.target.matches('.dropbtn')) {
        var dropdowns = document.getElementsByClassName("dropdown-content");
        var i;
        for (i = 0; i < dropdowns.length; i++) {
          var openDropdown = dropdowns[i];
          if (openDropdown.classList.contains('show')) {
            openDropdown.classList.remove('show');
          }
        }
      }
    }


let wacPreview = null;
let wPressed = false;

let hrcPreview = null;
let hPressed = false;

let enfysPreview = null;
let ePressed = false;

function onMouseMove1(event) {
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);

  const intersects = raycaster.intersectObject(sphere);

  if (intersects.length > 0) {
    const intersectPoint = intersects[0].point.clone();

    // Convert intersection point to spherical coordinates
    const spherical = new THREE.Spherical();
    spherical.setFromVector3(intersectPoint);

    if (wacPreview) {
      scene.remove(wacPreview);
      wacPreview.geometry.dispose();
      wacPreview.material.dispose();
      wacPreview = null;
    }

    const wacangle = 38.3/2 * (Math.PI / 180);

    wacPreview = new THREE.Mesh(
      new THREE.SphereGeometry(
        gen_radius - 0.2,
        16,
        16,
        spherical.theta + Math.PI / 2 - wacangle,
        wacangle * 2,
        spherical.phi - wacangle,
        wacangle * 2
      ),
      new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.4,
        side: THREE.BackSide,
        depthTest: false,
      }))

    wacPreview.position.set(0, 0, 0);
    scene.add(wacPreview);
  
  }
}
function onMouseMove2(event) {
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

  raycaster.setFromCamera(mouse, camera);

  const intersects = raycaster.intersectObject(sphere);

  if (intersects.length > 0) {
    const intersectPoint = intersects[0].point.clone();

    // Convert intersection point to spherical coordinates
    const spherical = new THREE.Spherical();
    spherical.setFromVector3(intersectPoint);

    if (hrcPreview) {
      scene.remove(hrcPreview);
      hrcPreview.geometry.dispose();
      hrcPreview.material.dispose();
      hrcPreview = null;
    }

    const hrcangle = 4.88/2 * (Math.PI / 180);

    hrcPreview = new THREE.Mesh(
      new THREE.SphereGeometry(
        gen_radius - 0.2,
        16,
        16,
        spherical.theta + Math.PI / 2 - hrcangle,
        hrcangle * 2,
        spherical.phi - hrcangle,
        hrcangle * 2
      ),
      new THREE.MeshBasicMaterial({
        color: 0x0000ff,
        transparent: true,
        opacity: 0.4,
        side: THREE.BackSide,
        depthTest: false,
      }))

    hrcPreview.position.set(0, 0, 0);
    scene.add(hrcPreview);
  
  }
}

function onMouseMove3(event) {
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

  raycaster.setFromCamera(mouse, camera);

  const intersects = raycaster.intersectObject(sphere);

  if (intersects.length > 0) {
    const intersectPoint = intersects[0].point.clone();

    // Convert intersection point to spherical coordinates
    const spherical = new THREE.Spherical();
    spherical.setFromVector3(intersectPoint);

    if (enfysPreview) {
      scene.remove(enfysPreview);
      enfysPreview.geometry.dispose();
      enfysPreview.material.dispose();
      enfysPreview = null;
    }

    const enfysangle = 0.5 * (Math.PI / 180);

    enfysPreview = new THREE.Mesh(
      new THREE.SphereGeometry(
        gen_radius - 0.2,
        16,
        16,
        spherical.theta + Math.PI / 2 - enfysangle,
        enfysangle * 2,
        spherical.phi - enfysangle,
        enfysangle * 2
      ),
      new THREE.MeshBasicMaterial({
        color: 0x00FF00,
        transparent: true,
        opacity: 0.4,
        side: THREE.BackSide,
        depthTest: false,
      })
    );

    enfysPreview.position.set(0, 0, 0);
    scene.add(enfysPreview);
  }
}


function onKeyDownWac(event) {
  if (event.key === "w" && !wPressed) {
    wPressed = true;
    renderer.domElement.addEventListener("mousemove", onMouseMove1);
  }
}

function onKeyUpWac(event) {
  if (event.key === "w") {
    wPressed = false;
    renderer.domElement.removeEventListener("mousemove", onMouseMove1);

    if (wacPreview) {
      scene.remove(wacPreview);
      wacPreview.geometry.dispose();
      wacPreview.material.dispose();
      wacPreview = null;
    }
  }
}


function onKeyDownHrc(event) {
  if (event.key === "h" && !hPressed) {
    hPressed = true;
    renderer.domElement.addEventListener("mousemove", onMouseMove2);
  }
}

function onKeyUpHrc(event) {
  if (event.key === "h") {
    hPressed = false;
    renderer.domElement.removeEventListener("mousemove", onMouseMove2);

    if (hrcPreview) {
      scene.remove(hrcPreview);
      hrcPreview.geometry.dispose();
      hrcPreview.material.dispose();
      hrcPreview = null;
    }
  }
}

function onKeyDownEnfys(event) {
  if (event.key === "e" && !ePressed) {
    ePressed = true;
    renderer.domElement.addEventListener("mousemove", onMouseMove3);
  }
}

function onKeyUpEnfys(event) {
  if (event.key === "e") {
    ePressed = false;
    renderer.domElement.removeEventListener("mousemove", onMouseMove3);

    if (enfysPreview) {
      scene.remove(enfysPreview);
      enfysPreview.geometry.dispose();
      enfysPreview.material.dispose();
      enfysPreview = null;
    }
  }
}

window.addEventListener("keydown", onKeyDownWac);
window.addEventListener("keyup", onKeyUpWac);

window.addEventListener("keydown", onKeyDownHrc);
window.addEventListener("keyup", onKeyUpHrc);

window.addEventListener("keydown", onKeyDownEnfys);
window.addEventListener("keyup", onKeyUpEnfys);

function onWindowResize() {
  const width = window.innerWidth;
  const height = window.innerHeight;

  camera.aspect = width / height;
  camera.updateProjectionMatrix();
  
  renderer.setSize(container.clientWidth, container.clientHeight);
  renderer.setPixelRatio(window.devicePixelRatio);


  
}

// Listen for resize events
window.addEventListener('resize', onWindowResize, false);

function jsonDownload(){
    const a = document.querySelector('a');

    //suggestionData.push(markers);

    const data = JSON.stringify(suggestionData, null, 2);

    const blob = new Blob([data], {type: 'text/json'});

    const url = URL.createObjectURL(blob);

    a.href = url;
    a.download = 'example.json';
}

let uploadedJson = null;
document.getElementById('jsonFile').addEventListener('change', function(event) {
            const file = event.target.files[0];
            clearMarkers();
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    uploadedJson = JSON.parse(e.target.result);
                    console.log("JSON loaded successfully:", uploadedJson);

                    // Now you can use uploadedJson anywhere in your code
                } catch (error) {
                    console.error('Invalid JSON file.', error);
                }
            };
            reader.readAsText(file);
        });

function jsonUpload() {

  if (uploadedJson) {
                console.log("Using JSON data:", uploadedJson);

                for (let i = 0; i < uploadedJson.length; i++) {
                
                const mouse = uploadedJson[i].mouse;

                const position = new THREE.Vector3(mouse.x, mouse.y, mouse.z);

                const data = uploadedJson[i];
                placeMarker(position, data);
                }

            } else {
                console.warn("No JSON file uploaded yet.");
            }
        }



  </script>

</body>
</html>
